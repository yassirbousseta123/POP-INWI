"""
Recommendation Engine for Incident Lens
Generates actionable recommendations based on root cause analysis
"""
import pandas as pd
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from enum import Enum

try:
    from .analyzer import RootCause, RootCauseType
except ImportError:
    import sys
    import os
    sys.path.append(os.path.dirname(os.path.dirname(__file__)))
    from incident_lens.analyzer import RootCause, RootCauseType


class RecommendationPriority(Enum):
    """Priority levels for recommendations"""
    IMMEDIATE = "immediate"      # < 1 hour
    URGENT = "urgent"           # < 4 hours  
    HIGH = "high"               # < 24 hours
    MEDIUM = "medium"           # < 1 week
    LOW = "low"                 # Routine maintenance


class RecommendationType(Enum):
    """Types of recommendations"""
    EMERGENCY_ACTION = "emergency_action"
    PREVENTIVE_MAINTENANCE = "preventive_maintenance"
    CONFIGURATION_CHANGE = "configuration_change"
    MONITORING_ENHANCEMENT = "monitoring_enhancement"
    TRAINING_REQUIRED = "training_required"
    INFRASTRUCTURE_UPGRADE = "infrastructure_upgrade"


@dataclass
class Recommendation:
    """Single actionable recommendation"""
    title: str
    description: str
    priority: RecommendationPriority
    type: RecommendationType
    estimated_time: str  # e.g., "30 minutes", "2 hours"
    responsible_team: str
    steps: List[str] = field(default_factory=list)
    resources_needed: List[str] = field(default_factory=list)
    expected_outcome: str = ""
    related_causes: List[str] = field(default_factory=list)
    cost_estimate: Optional[str] = None
    
    
@dataclass
class MaintenanceSchedule:
    """Schedule for preventive maintenance"""
    task: str
    frequency: str  # e.g., "weekly", "monthly", "quarterly"
    next_due: datetime
    estimated_duration: str
    responsible_team: str
    

class RecommendationEngine:
    """
    Generates actionable recommendations based on root cause analysis results
    Provides immediate actions, preventive measures, and long-term improvements
    """
    
    def __init__(self):
        """Initialize recommendation engine with knowledge base"""
        self.knowledge_base = self._build_knowledge_base()
        self.maintenance_templates = self._build_maintenance_templates()
        
    def _build_knowledge_base(self) -> Dict[str, Dict]:
        """Build knowledge base of cause-to-recommendation mappings"""
        return {
            RootCauseType.CLIM_TOTAL_FAILURE.value: {
                'immediate_actions': [
                    {
                        'title': 'üö® Intervention d\'urgence CLIM',
                        'description': 'Toutes les unit√©s CLIM sont hors service - risque critique pour les √©quipements',
                        'priority': RecommendationPriority.IMMEDIATE,
                        'type': RecommendationType.EMERGENCY_ACTION,
                        'estimated_time': '30 minutes',
                        'responsible_team': '√âquipe technique sur site',
                        'steps': [
                            'V√©rifier l\'alimentation √©lectrique des unit√©s CLIM',
                            'Contr√¥ler les disjoncteurs et fusibles',
                            'Red√©marrer les unit√©s si possible',
                            'Activer le plan de contingence thermique',
                            'Contacter le service de maintenance CLIM'
                        ],
                        'resources_needed': ['Multim√®tre', 'Cl√©s de maintenance', 'T√©l√©phone d\'urgence'],
                        'expected_outcome': 'Restauration partielle ou totale du refroidissement'
                    }
                ],
                'preventive_actions': [
                    {
                        'title': 'üîß Maintenance pr√©ventive CLIM renforc√©e',
                        'description': 'Programme de maintenance intensifi√© pour √©viter les pannes simultan√©es',
                        'priority': RecommendationPriority.HIGH,
                        'type': RecommendationType.PREVENTIVE_MAINTENANCE,
                        'estimated_time': '4 heures',
                        'responsible_team': 'Service maintenance',
                        'steps': [
                            'Planifier maintenance √©chelonn√©e des unit√©s',
                            'Contr√¥ler √©tat des filtres et √©changeurs',
                            'V√©rifier les capteurs de temp√©rature',
                            'Tester les syst√®mes de d√©marrage automatique'
                        ]
                    }
                ]
            },
            
            RootCauseType.CLIM_PARTIAL_FAILURE.value: {
                'immediate_actions': [
                    {
                        'title': '‚ö° Diagnostic unit√©s CLIM d√©faillantes',
                        'description': 'Identifier et r√©parer les unit√©s CLIM en panne',
                        'priority': RecommendationPriority.URGENT,
                        'type': RecommendationType.EMERGENCY_ACTION,
                        'estimated_time': '1-2 heures',
                        'responsible_team': 'Technicien CLIM',
                        'steps': [
                            'Identifier les unit√©s sp√©cifiquement en panne',
                            'V√©rifier l\'alimentation √©lectrique de chaque unit√©',
                            'Contr√¥ler les commandes et capteurs',
                            'Effectuer red√©marrage si n√©cessaire',
                            'Documenter les d√©faillances'
                        ],
                        'resources_needed': ['Outils de diagnostic', 'Pi√®ces de rechange courantes'],
                        'expected_outcome': 'Restauration des unit√©s d√©faillantes'
                    }
                ]
            },
            
            RootCauseType.DOOR_EXTENDED_OPEN.value: {
                'immediate_actions': [
                    {
                        'title': 'üö™ V√©rification syst√®me de fermeture',
                        'description': 'Contr√¥ler et r√©parer le syst√®me de fermeture automatique des portes',
                        'priority': RecommendationPriority.URGENT,
                        'type': RecommendationType.EMERGENCY_ACTION,
                        'estimated_time': '45 minutes',
                        'responsible_team': '√âquipe s√©curit√©/maintenance',
                        'steps': [
                            'V√©rifier le fonctionnement du ferme-porte automatique',
                            'Contr√¥ler les capteurs de porte',
                            'Ajuster la temporisation de fermeture',
                            'Tester les alertes de porte ouverte'
                        ]
                    }
                ],
                'preventive_actions': [
                    {
                        'title': 'üë• Formation du personnel',
                        'description': 'Sensibilisation aux proc√©dures d\'acc√®s et impact thermique',
                        'priority': RecommendationPriority.MEDIUM,
                        'type': RecommendationType.TRAINING_REQUIRED,
                        'estimated_time': '2 heures',
                        'responsible_team': 'Responsable s√©curit√©',
                        'steps': [
                            'Organiser session de sensibilisation',
                            'Rappeler les proc√©dures d\'acc√®s',
                            'Expliquer l\'impact thermique des portes ouvertes',
                            'Installer signalisation de rappel'
                        ]
                    }
                ]
            },
            
            RootCauseType.EXTERNAL_HEAT_WAVE.value: {
                'immediate_actions': [
                    {
                        'title': '‚ùÑÔ∏è Renforcement refroidissement',
                        'description': 'Optimiser la capacit√© de refroidissement face √† la chaleur externe',
                        'priority': RecommendationPriority.HIGH,
                        'type': RecommendationType.CONFIGURATION_CHANGE,
                        'estimated_time': '1 heure',
                        'responsible_team': 'Op√©rateur technique',
                        'steps': [
                            'R√©duire les consignes de temp√©rature si possible',
                            'Optimiser la circulation d\'air',
                            'V√©rifier l\'isolation des entr√©es d\'air',
                            'Surveiller de pr√®s les pr√©visions m√©t√©o'
                        ]
                    }
                ],
                'long_term_actions': [
                    {
                        'title': 'üèóÔ∏è Am√©lioration isolation thermique',
                        'description': 'Renforcer l\'isolation du b√¢timent contre les variations externes',
                        'priority': RecommendationPriority.LOW,
                        'type': RecommendationType.INFRASTRUCTURE_UPGRADE,
                        'estimated_time': '1 semaine',
                        'responsible_team': 'Bureau d\'√©tudes',
                        'cost_estimate': '5000-15000 EUR'
                    }
                ]
            },
            
            RootCauseType.IT_POWER_SURGE.value: {
                'immediate_actions': [
                    {
                        'title': 'üíª Analyse charge IT',
                        'description': 'Identifier et √©quilibrer les √©quipements √† forte consommation',
                        'priority': RecommendationPriority.HIGH,
                        'type': RecommendationType.CONFIGURATION_CHANGE,
                        'estimated_time': '2 heures',
                        'responsible_team': 'Administrateur syst√®me',
                        'steps': [
                            'Identifier les √©quipements √† forte charge',
                            'V√©rifier les t√¢ches de calcul intensives',
                            '√âquilibrer la distribution de charge',
                            'Planifier les t√¢ches gourmandes aux heures fra√Æches'
                        ]
                    }
                ]
            }
        }
        
    def _build_maintenance_templates(self) -> Dict[str, MaintenanceSchedule]:
        """Build templates for recurring maintenance tasks"""
        base_date = datetime.now()
        
        return {
            'clim_filter_check': MaintenanceSchedule(
                task='Contr√¥le et nettoyage filtres CLIM',
                frequency='monthly',
                next_due=base_date + timedelta(days=30),
                estimated_duration='2 heures',
                responsible_team='Service maintenance'
            ),
            'temperature_sensor_calibration': MaintenanceSchedule(
                task='√âtalonnage capteurs de temp√©rature',
                frequency='quarterly',
                next_due=base_date + timedelta(days=90),
                estimated_duration='4 heures',
                responsible_team='Service m√©trologie'
            ),
            'door_system_check': MaintenanceSchedule(
                task='V√©rification syst√®me fermeture portes',
                frequency='monthly',
                next_due=base_date + timedelta(days=30),
                estimated_duration='1 heure',
                responsible_team='Service s√©curit√©'
            ),
            'power_analysis': MaintenanceSchedule(
                task='Analyse consommation √©nerg√©tique',
                frequency='weekly',
                next_due=base_date + timedelta(days=7),
                estimated_duration='30 minutes',
                responsible_team='Responsable √©nergie'
            )
        }
    
    def generate_recommendations(self, 
                               root_causes: List[RootCause],
                               incident_severity: str = "medium",
                               historical_data: Optional[pd.DataFrame] = None) -> List[Recommendation]:
        """
        Generate prioritized recommendations based on root causes
        
        Args:
            root_causes: List of identified root causes
            incident_severity: Severity level of the incident
            historical_data: Optional historical data for pattern analysis
            
        Returns:
            List of recommendations sorted by priority
        """
        recommendations = []
        
        # Generate recommendations for each root cause
        for cause in root_causes:
            cause_recommendations = self._get_recommendations_for_cause(cause, incident_severity)
            recommendations.extend(cause_recommendations)
            
        # Add pattern-based recommendations if historical data available
        if historical_data is not None:
            pattern_recommendations = self._analyze_patterns_and_recommend(root_causes, historical_data)
            recommendations.extend(pattern_recommendations)
            
        # Remove duplicates and prioritize
        unique_recommendations = self._deduplicate_recommendations(recommendations)
        prioritized_recommendations = self._prioritize_recommendations(unique_recommendations, incident_severity)
        
        return prioritized_recommendations
        
    def _get_recommendations_for_cause(self, cause: RootCause, severity: str) -> List[Recommendation]:
        """Get recommendations for a specific root cause"""
        recommendations = []
        cause_key = cause.cause_type.value
        
        if cause_key not in self.knowledge_base:
            # Generic recommendation for unknown causes
            return [Recommendation(
                title='üîç Investigation approfondie requise',
                description=f'Cause non standard d√©tect√©e: {cause.description}',
                priority=RecommendationPriority.HIGH,
                type=RecommendationType.EMERGENCY_ACTION,
                estimated_time='1 heure',
                responsible_team='Expert technique',
                steps=['Analyser les donn√©es en d√©tail', 'Consulter la documentation technique'],
                related_causes=[cause_key]
            )]
            
        cause_kb = self.knowledge_base[cause_key]
        
        # Add immediate actions
        if 'immediate_actions' in cause_kb:
            for action in cause_kb['immediate_actions']:
                rec = self._create_recommendation_from_template(action, cause)
                recommendations.append(rec)
                
        # Add preventive actions if not critical severity
        if severity != "critical" and 'preventive_actions' in cause_kb:
            for action in cause_kb['preventive_actions']:
                rec = self._create_recommendation_from_template(action, cause)
                recommendations.append(rec)
                
        # Add long-term actions for recurring issues
        if cause.confidence > 70 and 'long_term_actions' in cause_kb:
            for action in cause_kb['long_term_actions']:
                rec = self._create_recommendation_from_template(action, cause)
                recommendations.append(rec)
                
        return recommendations
        
    def _create_recommendation_from_template(self, template: Dict, cause: RootCause) -> Recommendation:
        """Create recommendation object from template"""
        return Recommendation(
            title=template['title'],
            description=template['description'],
            priority=template['priority'],
            type=template['type'],
            estimated_time=template['estimated_time'],
            responsible_team=template['responsible_team'],
            steps=template.get('steps', []),
            resources_needed=template.get('resources_needed', []),
            expected_outcome=template.get('expected_outcome', ''),
            related_causes=[cause.cause_type.value],
            cost_estimate=template.get('cost_estimate')
        )
        
    def _analyze_patterns_and_recommend(self, causes: List[RootCause], data: pd.DataFrame) -> List[Recommendation]:
        """Analyze historical patterns and generate additional recommendations"""
        recommendations = []
        
        # Check for recurring cause patterns
        cause_types = [c.cause_type.value for c in causes]
        
        # If CLIM issues are frequent, recommend infrastructure review
        clim_causes = [c for c in cause_types if 'clim' in c]
        if len(clim_causes) > 0:
            recommendations.append(Recommendation(
                title='üìä Audit syst√®me CLIM',
                description='Incidents CLIM r√©currents d√©tect√©s - audit complet recommand√©',
                priority=RecommendationPriority.MEDIUM,
                type=RecommendationType.PREVENTIVE_MAINTENANCE,
                estimated_time='1 jour',
                responsible_team='Bureau d\'√©tudes',
                steps=[
                    'Analyser l\'historique des pannes CLIM',
                    '√âvaluer l\'√¢ge et l\'√©tat des √©quipements',
                    'Calculer le ROI d\'un remplacement',
                    'Proposer un plan de modernisation'
                ],
                related_causes=clim_causes
            ))
            
        # Check for seasonal patterns
        if len(data) > 24*7:  # More than a week of data
            seasonal_rec = self._analyze_seasonal_patterns(data)
            if seasonal_rec:
                recommendations.append(seasonal_rec)
                
        return recommendations
        
    def _analyze_seasonal_patterns(self, data: pd.DataFrame) -> Optional[Recommendation]:
        """Analyze seasonal patterns in the data"""
        if 'T¬∞C EXTERIEURE' not in data.columns:
            return None
            
        # Simple seasonal analysis - could be enhanced
        avg_ext_temp = data['T¬∞C EXTERIEURE'].mean()
        
        if avg_ext_temp > 32:  # Hot period
            return Recommendation(
                title='üå°Ô∏è Pr√©paration p√©riode chaude',
                description='Temp√©ratures ext√©rieures √©lev√©es d√©tect√©es - renforcer la pr√©paration',
                priority=RecommendationPriority.MEDIUM,
                type=RecommendationType.PREVENTIVE_MAINTENANCE,
                estimated_time='4 heures',
                responsible_team='Service maintenance',
                steps=[
                    'V√©rifier la capacit√© de refroidissement maximale',
                    'Nettoyer les √©changeurs externes',
                    'Contr√¥ler les niveaux de fluide frigorig√®ne',
                    'Pr√©voir des ventilateurs d\'appoint si n√©cessaire'
                ]
            )
        return None
        
    def _deduplicate_recommendations(self, recommendations: List[Recommendation]) -> List[Recommendation]:
        """Remove duplicate recommendations based on title"""
        seen_titles = set()
        unique_recommendations = []
        
        for rec in recommendations:
            if rec.title not in seen_titles:
                seen_titles.add(rec.title)
                unique_recommendations.append(rec)
            else:
                # Merge related causes for duplicates
                existing = next(r for r in unique_recommendations if r.title == rec.title)
                existing.related_causes.extend(rec.related_causes)
                existing.related_causes = list(set(existing.related_causes))  # Remove duplicates
                
        return unique_recommendations
        
    def _prioritize_recommendations(self, recommendations: List[Recommendation], severity: str) -> List[Recommendation]:
        """Sort recommendations by priority and adjust based on incident severity"""
        
        # Priority order mapping
        priority_order = {
            RecommendationPriority.IMMEDIATE: 1,
            RecommendationPriority.URGENT: 2,
            RecommendationPriority.HIGH: 3,
            RecommendationPriority.MEDIUM: 4,
            RecommendationPriority.LOW: 5
        }
        
        # Adjust priorities based on incident severity
        if severity == "critical":
            for rec in recommendations:
                if rec.priority in [RecommendationPriority.HIGH, RecommendationPriority.URGENT]:
                    rec.priority = RecommendationPriority.IMMEDIATE
                elif rec.priority == RecommendationPriority.MEDIUM:
                    rec.priority = RecommendationPriority.URGENT
                    
        elif severity == "high":
            for rec in recommendations:
                if rec.priority == RecommendationPriority.HIGH:
                    rec.priority = RecommendationPriority.URGENT
                elif rec.priority == RecommendationPriority.MEDIUM:
                    rec.priority = RecommendationPriority.HIGH
                    
        # Sort by priority
        return sorted(recommendations, key=lambda r: priority_order[r.priority])
        
    def generate_maintenance_schedule(self, 
                                    causes: List[RootCause],
                                    horizon_days: int = 90) -> List[MaintenanceSchedule]:
        """
        Generate maintenance schedule based on identified issues
        
        Args:
            causes: Root causes to address
            horizon_days: Planning horizon in days
            
        Returns:
            List of scheduled maintenance tasks
        """
        schedule = []
        base_date = datetime.now()
        end_date = base_date + timedelta(days=horizon_days)
        
        # Add relevant maintenance tasks based on causes
        cause_types = [c.cause_type.value for c in causes]
        
        for cause_type in cause_types:
            if 'clim' in cause_type:
                # Add CLIM-related maintenance
                clim_tasks = ['clim_filter_check', 'temperature_sensor_calibration']
                for task_key in clim_tasks:
                    if task_key in self.maintenance_templates:
                        task = self.maintenance_templates[task_key]
                        if task.next_due <= end_date:
                            schedule.append(task)
                            
            elif 'door' in cause_type:
                # Add door-related maintenance
                if 'door_system_check' in self.maintenance_templates:
                    task = self.maintenance_templates['door_system_check']
                    if task.next_due <= end_date:
                        schedule.append(task)
                        
            elif 'power' in cause_type:
                # Add power analysis
                if 'power_analysis' in self.maintenance_templates:
                    task = self.maintenance_templates['power_analysis']
                    if task.next_due <= end_date:
                        schedule.append(task)
                        
        # Sort by due date
        return sorted(schedule, key=lambda s: s.next_due)
        
    def format_recommendations_for_display(self, recommendations: List[Recommendation]) -> str:
        """Format recommendations for text display"""
        if not recommendations:
            return "Aucune recommandation sp√©cifique - surveillance continue recommand√©e."
            
        output = []
        
        # Group by priority
        by_priority = {}
        for rec in recommendations:
            priority = rec.priority.value
            if priority not in by_priority:
                by_priority[priority] = []
            by_priority[priority].append(rec)
            
        # Priority order for display
        priority_order = ['immediate', 'urgent', 'high', 'medium', 'low']
        priority_labels = {
            'immediate': 'üö® ACTIONS IMM√âDIATES',
            'urgent': '‚ö° ACTIONS URGENTES', 
            'high': 'üî¥ HAUTE PRIORIT√â',
            'medium': 'üü° PRIORIT√â MOYENNE',
            'low': 'üü¢ ACTIONS PR√âVENTIVES'
        }
        
        for priority in priority_order:
            if priority in by_priority:
                output.append(f"\n{priority_labels[priority]}")
                output.append("=" * 50)
                
                for i, rec in enumerate(by_priority[priority], 1):
                    output.append(f"\n{i}. {rec.title}")
                    output.append(f"   √âquipe: {rec.responsible_team}")
                    output.append(f"   Dur√©e estim√©e: {rec.estimated_time}")
                    output.append(f"   Description: {rec.description}")
                    
                    if rec.steps:
                        output.append("   √âtapes:")
                        for step in rec.steps:
                            output.append(f"   ‚Ä¢ {step}")
                            
                    if rec.resources_needed:
                        resources = ", ".join(rec.resources_needed)
                        output.append(f"   Ressources: {resources}")
                        
                    if rec.cost_estimate:
                        output.append(f"   Co√ªt estim√©: {rec.cost_estimate}")
                        
        return "\n".join(output)
        
    def export_recommendations_to_json(self, recommendations: List[Recommendation]) -> Dict[str, Any]:
        """Export recommendations to JSON format"""
        return {
            'generated_at': datetime.now().isoformat(),
            'total_recommendations': len(recommendations),
            'recommendations': [
                {
                    'title': rec.title,
                    'description': rec.description,
                    'priority': rec.priority.value,
                    'type': rec.type.value,
                    'estimated_time': rec.estimated_time,
                    'responsible_team': rec.responsible_team,
                    'steps': rec.steps,
                    'resources_needed': rec.resources_needed,
                    'expected_outcome': rec.expected_outcome,
                    'related_causes': rec.related_causes,
                    'cost_estimate': rec.cost_estimate
                }
                for rec in recommendations
            ]
        }